
ASSEMBLEM

!RPL

::
CODEM

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 		SuperMarioHP50 Level Editor
%
% 		Arrow to move cursor
% 		+/- to Draw tile
% 		+ or - to Select tile
% 		G or I to change page
% 		Enter to quit
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SAVE
INTOFF
CLRST

DC HEADERADD 	00128  	%  Header height
DC SCREENADD 	00120  	%  Screen address
DC HEXDCW 	2DEAA  	%  Make Hex
DC KEY    	0020F  	%  OUT=C C=IN
DC SCREEN	8068D	%  Screen

% Editor Constants
DC TW_MAX  	D 	% #13
DC TH_MAX  	8 	% #8

% Constants for the Annunciator bit locations below
DC ANNUNCIATORS_IO 1
DC ANNUNCIATORS_Alert 3
DC ANNUNCIATORS_LShift 4
DC ANNUNCIATORS_RShift 5
DC ANNUNCIATORS_Alpha 6
DC ANNUNCIATORS_Busy 7
DC ANNCTRL_LShift 0
DC ANNCTRL_RShift 1
DC ANNCTRL_Alpha 2
DC ANNCTRL_Alert 3
DC ANNCTRL_Busy 4
DC ANNCTRL_IO 5
DC PASTDUE_flag 0
   
CP=80100
DCCP 5 EC0             	% address of our custom screen surface
DCCP 5 EC1             	% address of our offscreen surface
DCCP 5 X
DCCP 5 Y
DCCP 5 B
DCCP 5 S
DCCP 5 X2 		%

% Clear our allocated constantes addresses
A=0.A
D0=(5)EC0 DAT0=A.A
D0=(5)EC1 DAT0=A.A
D0=(5)X DAT0=A.A
D0=(5)Y DAT0=A.A
D0=(5)B DAT0=A.A
D0=(5)S DAT0=A.A
D0=(5)X2 DAT0=A.A


GOSUBL HIDE_MENU
GOSUBL HIDE_ANNUN
GOSUBL INIT_SCREENS
GOSUBL INI.STACK
GOSUBL DISP.LEVEL

*LCD

% Monochrome
D1=(5)EC1 A=DAT1.A D1=A
GOSUBL AF
GOTO NOGS

% Grayscale

A=0.W
D0=(5) $00128 % HEADERADD
{
 A=DAT0 6
 ?A#0.W UP
}
D1=(5)EC1 A=DAT1.A D1=A
GOSUBL AF

A=0.W
D0=(5) $00128 % HEADERADD
{
 A=DAT0 6
 ?A#0.W UP
}
D1=(5)EC1 A=DAT1.A
LC(5)$00AA0 A+C.A
D1=A
GOSUBL AF

A=0.W
D0=(5) $00128 % HEADERADD
{
 A=DAT0 6
 ?A#0.W UP
}
D1=(5)EC1 A=DAT1.A
LC(5)$00AA0 A+C.A
D1=A
%GOSUBL AF

% end of grayscale

*NOGS

GOSUBL TAB
GOSUBL TNEXT
GOSUBL TPREV
GOSUBL TDRAW
GOSUBL CUBE.P
GOSUBL CUBE.M

LC 06000 { C-1.A UPNC }  % Slow up !

GOSUBL JUCURSOR
GOSUBL TD      % detect move right
GOSUBL TG      % detect move left
GOSUBL TH      % detect move up
GOSUBL TB      % detect move down
GOSUBL TQ      % detect press quit
GOLONG LCD


*INIT_SCREENS
% create custom screen surface and store address in EC0
LC(5)$00AA1 GOSBVL =MAKE$N
D0+1 AD0EX ABIT=0.0
D0=(5)EC0 DAT0=A.A

% Clear our custom screen surface
D0=(5)EC0 A=DAT0.A D0=A
LC(2)$AA
A=0.W
{ DAT0=A.W D0+16 C-1.B UPNC }

% create offscreen surface and store address in EC1
LC(5)$00AA1 GOSBVL =MAKE$N % LC(5)$01541
D0+1 AD0EX ABIT=0.0
D0=(5)EC1 DAT0=A.A

% Clear our offscreen surface
D0=(5)EC1 A=DAT0.A D0=A
LC(2)$AA % $154
A=0.W
{ DAT0=A.W D0+16 C-1.B UPNC }

% Assign out custom screen surface EC0 to Screen
D0=(5)EC0 A=DAT0.A D0=(5)SCREENADD DAT0=A.A
RTN

*AF
D0=(5)EC0 A=DAT0.A D0=A
LC(2)$AA
{
 A=DAT1.W DAT0=A.W
 D0+16 D1+16
 C-1.B UPNC
}
RTN

*TQ
LC 001 GOSBVL =KEY
?CBIT=0.0 RTNYES
*QUIT
LC(3)$1FF
GOSBVL =KEY
?C#0.B GOYES QUIT

*FINALQUIT
GOSUBL SHOW_MENU
D0=(5)SCREEN A=DAT0.A D0=(5)SCREENADD DAT0=A.A
LOADRPL

*JUCURSOR
?ST=0.0 ->{ ST=1.0 } SKELSE { RTN }
*NCURSER
D0=(5)EC1 A=DAT0.A
GOSUBL XY
D0=A
LC 7 {
A=DAT0.B A=-A-1.B DAT0=A.B
D0+34 C-1.P UPNC }
RTN

*TD
LC 040 GOSBVL =KEY
?CBIT=0.0 RTNYES
D0=(5)X A=DAT0.A
LC(5)#12
?A=C.B RTNYES
?ST=1.0 ->{ ST=0.0 GOSUBL NCURSER }
D0=(5)X A=DAT0.B
A+1.B
DAT0=A.B
A=R2.A A+2.A R2=A.A
GOSUBL JUCURSOR
RTN

*TG
LC 040 GOSBVL =KEY
?CBIT=0.2 RTNYES
D0=(5)X A=DAT0.B
?A=0.B RTNYES
?ST=1.0 ->{ ST=0.0 GOSUBL NCURSER }
D0=(5)X A=DAT0.B
A-1.B
DAT0=A.B
A=R2.A A-2.A R2=A.A
GOSUBL JUCURSOR
RTN

*TB
LC 040 GOSBVL =KEY
?CBIT=0.1 RTNYES
D0=(5)Y A=DAT0.B
LC 07 ?A=C.B RTNYES
?ST=1.0 ->{ ST=0.0 GOSUBL NCURSER }
D0=(5)Y A=DAT0.B
A+1.B DAT0=A.B
A=R2.A
LC 00140 A+C.A
R2=A.A
GOSUBL JUCURSOR
RTN

*TH
LC 040 GOSBVL =KEY
?CBIT=0.3 RTNYES
D0=(5)Y A=DAT0.B
?A=0.B RTNYES
?ST=1.0 ->{ ST=0.0 GOSUBL NCURSER }
D0=(5)Y A=DAT0.B
A-1.B DAT0=A.B
A=R2.A
LC 00140 A-C.A
R2=A.A
GOSUBL JUCURSOR
RTN

*XY
C=0.A
D0=(5)X C=DAT0.B C+C.A
A+C.A C=0.A
D0=(5)Y C=DAT0.B D=C.A
CSL.A C+D.A C+C.A
C+C.A C+C.A C+C.A
A+C.A
RTN

*TAB
% Editor menu at right
SKUBL {
$0FFFFFF70100000401000084015462B409AAA824098E6A24098AAA140100000401B9263409B26554098A253401B94354010000040100000409FFFFF40100000405100004055000040900000405500004051000040100000409FFFFF40100000405100004055000040900000409400004090000040100000409FFFFF40100000409570004050410040D520004015110040D4700040100000409FFFFF4010000040D470004051210040D52000405421004054200040100000409FFFFF4010000040D481004055440040D440004055440040DD91004010000040100000401000004010000040100000401000004010000040100000401000004010000040FFFFFF7
} C=RSTK D1=C

D0=(5)EC1
A=DAT0.A A+16.A
A+10.A D0=A D1+1
LC 3F
{
 A=DAT1.8
 DAT0=A.8 D0+34
 D1+8 C-1.B UPNC
}

GOSUBL CUBE
GOSUBL D.BLOC
GOSUBL D.SIZE
GOSUBL D.PIT
GOSUBL D.X
GOSUBL D.Y
RTN

*CUBE
% Display our selected Tile into Editor menu
A=R3.A D1=A
D0=(5)EC1 A=DAT0.A
LC 00749 A+C.A D0=A
LC 7
{
 A=DAT1.B
 DAT0=A.B D0+34
 D1+4
 C-1.P UPNC
}
RTN

*CUBE.P
LC 001 GOSBVL =KEY
?CBIT=0.1 RTNYES
D0=(5)B A=DAT0.B
LC(2)$2B ?A>=C.B RTNYES
A+1.B DAT0=A.B
LC 00020 A=R3.A A+C.A R3=A.A
GOSUBL CUBE
RTN

*CUBE.M
LC 001 GOSBVL =KEY
?CBIT=0.2 RTNYES
D0=(5)B A=DAT0.B
?A=0.B RTNYES
A-1.B DAT0=A.B
LC 00020 A=R3.A A-C.A R3=A.A
GOSUBL CUBE
RTN


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1: SML***   Nibbles in R2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

*INI.STACK
LOAD
SAVE
LC(5)#1283*#2 B=C.A
A=DAT1.A
?A=0.A GOYES MKS  		% SML*********** Level String not found ?
D0=A A=DAT0.A
LC(5)$02A2C ?A#C.A GOYES MKS 	% Object is no a String "C2A20" Header
D0+5 A=DAT0.A
A-5.A ?A#B.A GOYES MKS  	% String size not good (-5 header)

SKIP {
*MKS
	% Create level string
	C=B.A GOSBVL =MAKE$N
	LC(6)$4C4D53 DAT0=C.6  	% 35D4C4 = SML
	AD0EX A-10.A R0=A.A     % R0 = Start of String
	A+16.A D0=A             % D0 = Start of level nibbles
	LC(3)#159
	A=0.W
	{ DAT0=A.W D0+16
	C-1.X UPNC }      	% Clear level nibbles
	LOAD
	A=R0.A
	D-1.A
	SKIPNC { SAVE GOTO QUIT }
	D1-5 DAT1=A.A     	% Save Level on Stack
	SAVE
}

A=DAT1.A A+16.A R2=A.A  	%  R2=Level +5(header) +5(size) +6(SML)

LC(2)#13 D0=(5)X2 DAT0=C.B

%%%%%%%%%%%%%%%%%%%%%%%%%
% TILES DATAS  in R3
%%%%%%%%%%%%%%%%%%%%%%%%%

% Get Tiles surfaces and keep address to R3
SKUBL {
$00000000000000000000000000000000E7E7BAFF5DFFBAFF5DFFBAFF5DFFE7E7E7007E00BD00FD00FE00FF00FE00E700E7E7FF18FF1BFF19FF19FFD9FFD9E7E70000000000002200220022007700FF00FF00DB00FF00FF00FF00FF00DB00FF00FF00FB00FF00E500E500E500E500E5000000C10022001400140014002200C100000000008100C300C300810000000000EFFFFFFFFFFF59CF40CF40CF40CF40CFFF00FF00FF00C2000000000000000000F700FF00FF006B00020002000200020040004000400040004000400040004000020002000200020002000200020002008100C200C200C1008100C200C200C100080004000200010080004000200010001000200040008000010002000400080000000000000000008100420024001800EF00FF00FF0059000000000000000000FF00FF00FF00CA008100C200C200C100F700FF00FF006B000000000000000000FF00FF00FF00C2000000000000000000E7001800DB00DB00DB00DB00DB00DB00E7001800FB00FF000000000000000000E7001800FB00FB00FB00FB00FB00FF00C100C1008000E300D500C1004100630000000000C300A500FF007E00E7003C00EF001000930056005500D40093001000FF000000000000000000000000000000F7000800C9006A00AA002B00C9000800100010001000100010001000100010000800080008000800080008000800080010009300D4005500560093001000EF000800C9002B00AA006A00C9000800F7000000000000000000000000000000FF00E7003800FB00E7008000C0008000C100E7003800FB00E700810042000100C300FF001400180014001800FF0020002800FF00DF00AF00DF00AF00FF00D700A7002000280020002800CF00200028002000D700A700D700A700F300D700A700D700C600290010005000200014009800670077008800180006000800480084007300FF006F00A600DA00FD00FF00FF00FF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008
} C=RSTK
R3=C.A
RTN

*D.BLOC
D0=(5)EC1 A=DAT0.A
LC 0067F A+C.A
R4=A.A A=0.W
D0=(5)B A=DAT0.B
GOSBVL =HEXDCW SETHEX
LC 2 D=C.P
GOLONG DISP_N

*D.X
D0=(5)EC1 A=DAT0.A
LC 0023F A+C.A
R4=A.A A=0.W
D0=(5)X A=DAT0.A
D0=(5)S C=DAT0.A
*INC ?C#0.A ->{ C-1.A
A+13.A GOTO INC }
GOSBVL =HEXDCW SETHEX
LC 4 D=C.P
GOLONG DISP_N

*D.Y
D0=(5)EC1 A=DAT0.A
LC 0034F A+C.A
R4=A.A A=0.W
D0=(5)Y A=DAT0.B
GOSBVL =HEXDCW SETHEX
LC 4 D=C.P
GOLONG DISP_N

*D.SIZE
D0=(5)EC1 A=DAT0.A
LC 0045F A+C.A
R4=A.A A=0.W
D0=(5)X2 A=DAT0.B
GOSBVL =HEXDCW SETHEX
LC 2 D=C.P
GOLONG DISP_N

*D.PIT
D0=(5)EC1 A=DAT0.A
LC 0056F A+C.A
R4=A.A A=0.W
D0=(5)S A=DAT0.B A+1.B
GOSBVL =HEXDCW SETHEX
LC 2 D=C.P
GOLONG DISP_N

*DISP_N
GOSUBL GET_DAT
C=0.P

{
 ?B=C.P EXIT
 D1+1 C+1.P UP
}

*DSP
A=R4.A D0=A
LC 4  { A=DAT1.P
DAT0=A.P D0+34
D1+16 C-1.P UPNC }
BSR.A A=R4.A A-1.A R4=A.A
D-1.P ?D#0.P ->{ GOTO DISP_N }
RTN

*GET_DAT
GOSUBL DAT
$237757677723637752445114555515115277777277731577521444515455151127774771775363710000000000000000
*DAT
C=RSTK D1=C
RTN

*TDRAW
LC 008 GOSBVL =KEY
?CBIT=0.4 RTNYES

D0=(5)X A=DAT0.A
D0=(5)S C=DAT0.A
{
 ?C=0.A
 {
  C-1.A
  A+13.A
  UP2
 }
}
LC(5)#160
?A>=C.A RTNYES

?ST=1.0 ->{ ST=0.0
 GOSUBL NCURSER }
A=R3.A D1=A
%A=R0.A
D0=(5)EC1 A=DAT0.A
GOSUBL XY D0=A
LC 7
{ A=DAT1.B DAT0=A.B
D0+34 D1+4
C-1.P UPNC }
A=R2.A D0=A D1=(5)B
A=DAT1.B DAT0=A.B
GOSUBL JUCURSOR
RTN

*DISP.LEVEL
D0=(5)EC1 A=DAT0.A R4=A.A
LC(2)TW_MAX D=C.B % X
LC(2)TH_MAX B=C.B % Y
A=R2.A
D0=(5)X C=DAT0.B
{
 ?C=0.B EXIT
 C-1.B A-2.A UP
}
D0=(5)Y C=DAT0.B
RSTK=C
{
 C=RSTK
 ?C=0.B EXIT
 C-1.B RSTK=C
 LC 00140 A-C.A UP
}

D0=A CD0EX RSTK=C D0=C

*BCL
D1=(5)B C=DAT1.B
A=R3.A
{
 ?C=0.B EXIT
 A-32.A
 C-1.B UP
}
D1=A C=0.B
{
 A=DAT0.B ?A=C.B EXIT
 C+1.B D1+32 UP
}

A=R4.A D0=A
LC 7
{
 A=DAT1.B DAT0=A.B % Disp Tile Gray1

% RSTK=C
% LC(5)$00AA0
% AD0EX A+C.A D0=A
% D1+2 A=DAT1.B DAT0=A.B % Disp Tile Gray2
% AD0EX A-C.A D0=A
% C=RSTK

 D0+34
 D1+2
 D1+2

 C-1.P
 UPNC
}

A=R4.A A+2.A R4=A.A
C=RSTK C+2.A RSTK=C
D0=C

D-1.B ?D#0.B ->{ GOTO BCL }

% line of level done

LC(2)TW_MAX D=C.B

C=RSTK
LA(5)$00126 C+A.A
RSTK=C D0=C

% We rollback our pointer 13 * (8b=2q) left Then + 136*(8b=2q) = #110h
A=R4.A
A-26.A LC 00110 A+C.A
R4=A.A

B-1.B ?B#0.B ->{ GOTO BCL }
C=RSTK
D0=(5)S A=DAT0.B
LC(2)#12
?A<C.B RTNYES

%D0=(5)EC1
%A=DAT0.A A+8.A D0=A
%A=0.W LC 3F
%{
% DAT0=A.W D0+16
% DAT0=A.B D0+18
% C-1.B UPNC
%}
RTN

*TNEXT
LC 008 GOSBVL =KEY
?CBIT=0.7 RTNYES
D0=(5)S A=DAT0.B
D1=(5)X2 C=DAT1.B C-1.B
?A>=C.B RTNYES
A+1.B DAT0=A.B

A=R2.A A+26.A R2=A.A
GOSUBL DISP.LEVEL
ST=0.0
RTN

*TPREV
LC 020 GOSBVL =KEY
?CBIT=0.7 RTNYES
D0=(5)S A=DAT0.B
?A=0.B RTNYES
A-1.B DAT0=A.B

A=R2.A A-26.A R2=A.A
GOSUBL DISP.LEVEL
ST=0.0
RTN

*SHOW_ANNUN

      D1=(5)ANNUNCIATORS         % load address of ANNUNCIATORS in D1
      C=DAT1 B                   % copy the byte into C.B
      CBIT=1 ANNUNCIATORS_IO     % turn on the I/O Annunciator bit
      CBIT=1 ANNUNCIATORS_Alert  % turn on the Alert Annunciator bit
      CBIT=1 ANNUNCIATORS_LShift % turn on the Left Shift Annunciator bit
      CBIT=1 ANNUNCIATORS_RShift % turn on the Right Shift Annunciator bit
      CBIT=1 ANNUNCIATORS_Alpha  % turn on the Alpha Annunciator bit
      CBIT=1 ANNUNCIATORS_Busy   % turn on the Busy Annunciator bit
      DAT1=C B                   % write the byte back to memory

      D1=(5)ANNCTRL              % load address of ANNCTRL in D1
      C=DAT1 B                   % copy the byte into C.B
      CBIT=1 ANNCTRL_IO          % turn on the I/O Annunciator bit
      CBIT=1 ANNCTRL_Alert       % turn on the Alert Annunciator bit
      CBIT=1 ANNCTRL_LShift      % turn on the Left Shift Annunciator bit
      CBIT=1 ANNCTRL_RShift      % turn on the Right Shift Annunciator bit
      CBIT=1 ANNCTRL_Alpha       % turn on the Alpha Annunciator bit
      CBIT=1 ANNCTRL_Busy        % turn on the Busy Annunciator bit
      DAT1=C B                   % write the byte back to memory

      % set PASTDUE flag so that Alert annunciator will be left intact
      D1=(5)PASTDUE              % load address of PASTDUE into D
      C=DAT1 B                   % copy D1.B into C
      CBIT=1 PASTDUE_flag        % set appropriate bit (defined above) to 1
      DAT1=C B                   % copy C.B back into memory at PASTDUE
RTN

*HIDE_ANNUN

      D1=(5)ANNUNCIATORS         % load address of ANNUNCIATORS in D1
      C=DAT1 B                   % copy the byte into C.B
      CBIT=0 ANNUNCIATORS_IO     % turn off the I/O Annunciator bit
      CBIT=0 ANNUNCIATORS_Alert  % turn off the Alert Annunciator bit
      CBIT=0 ANNUNCIATORS_LShift % turn off the Left Shift Annunciator bit
      CBIT=0 ANNUNCIATORS_RShift % turn off the Right Shift Annunciator bit
      CBIT=0 ANNUNCIATORS_Alpha  % turn off the Alpha Annunciator bit
      CBIT=0 ANNUNCIATORS_Busy   % turn off the Busy Annunciator bit
      DAT1=C B                   % write the byte back to memory

      D1=(5)ANNCTRL              % load address of ANNCTRL in D1
      C=DAT1 B                   % copy the byte into C.B
      CBIT=0 ANNCTRL_IO          % turn off the I/O Annunciator bit
      CBIT=0 ANNCTRL_Alert       % turn off the Alert Annunciator bit
      CBIT=0 ANNCTRL_LShift      % turn off the Left Shift Annunciator bit
      CBIT=0 ANNCTRL_RShift      % turn off the Right Shift Annunciator bit
      CBIT=0 ANNCTRL_Alpha       % turn off the Alpha Annunciator bit
      CBIT=0 ANNCTRL_Busy        % turn off the Busy Annunciator bit
      DAT1=C B                   % write the byte back to memory

      D1=(5)PASTDUE              % load address of PASTDUE into D
      C=DAT1 B                   % copy D1.B into C
      CBIT=0 PASTDUE_flag        % set appropriate bit (defined above) to 0
      DAT1=C B                   % copy C.B back into memory at PASTDUE
RTN

*HIDE_MENU
LA 3F D0=(5)HEADERADD DAT0=A.B
RTN

*SHOW_MENU
LA 37 D0=(5)HEADERADD DAT0=A.B
RTN

ENDCODE
;
@
